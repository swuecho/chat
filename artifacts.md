# Artifact Feature Implementation Plan

## Overview

This document outlines the implementation plan for adding artifact support to the chat application. Artifacts are interactive code blocks, HTML previews, diagrams, and other rich content that can be generated by LLMs and displayed interactively in the chat interface.

## Current Architecture Analysis

### Database Schema

The `chat_message` table already has:

- `content` field for main message content
- `raw` JSONB field for raw LLM responses
- `reasoning_content` field for thinking/reasoning content

### Frontend Message Structure

```typescript
interface Message {
  uuid: string,
  dateTime: string
  text: string
  model?: string
  inversion?: boolean  // true for user messages, false for assistant
  error?: boolean
  loading?: boolean
  isPrompt?: boolean
  isPin?: boolean
}
```

### Current Message Flow

1. User Input → Frontend
2. API Call → `/chat_stream` endpoint
3. LLM Processing → Various providers
4. Response Streaming → Server-Sent Events
5. Database Storage → Full metadata
6. Frontend Update → UI refresh

## Implementation Plan

### 1. Database Schema Extension

#### Option A: Extend existing table

```sql
-- Add artifacts column to chat_message table
ALTER TABLE chat_message ADD COLUMN artifacts JSONB;
```

### 2. Backend Implementation

#### Data Structures

```go
// Add to message struct
type ChatMessage struct {
    // ... existing fields
    Artifacts []Artifact `json:"artifacts,omitempty"`
}

type Artifact struct {
    UUID     string `json:"uuid"`
    Type     string `json:"type"`
    Title    string `json:"title"`
    Content  string `json:"content"`
    Language string `json:"language,omitempty"`
}
```

#### Artifact Detection Logic

```go
// In message processing pipeline
func extractArtifacts(content string) []Artifact {
    // Detect code blocks with artifact markers
    // Pattern: ```language <!-- artifact: title -->
    // Extract HTML blocks with artifact markers
    // Detect SVG content
    // Find Mermaid diagrams
}
```

#### API Endpoints

- Extend existing message endpoints to include artifact data
- Add artifact-specific endpoints if needed:
  - `GET /api/artifacts/:uuid` - Get artifact content
  - `PUT /api/artifacts/:uuid` - Update artifact (if editing supported)
  - `DELETE /api/artifacts/:uuid` - Delete artifact
  - `GET /api/artifacts` - List all artifacts for a user

### 3. Frontend Components

#### Core Components

```vue
<!-- ArtifactViewer.vue -->
<template>
  <div class="artifact-container">
    <div class="artifact-header">
      <span class="artifact-title">{{ artifact.title }}</span>
      <div class="artifact-actions">
        <button @click="toggleExpanded">{{ expanded ? 'Collapse' : 'Expand' }}</button>
        <button @click="copyContent">Copy</button>
        <button @click="downloadContent">Download</button>
      </div>
    </div>
    <div v-if="expanded" class="artifact-content">
      <component :is="getArtifactComponent(artifact.type)" :artifact="artifact" />
    </div>
  </div>
</template>
```

#### Artifact Type Components

- `CodeArtifact.vue` - Interactive code editor with syntax highlighting
- `HtmlArtifact.vue` - Sandboxed HTML preview
- `SvgArtifact.vue` - SVG viewer with zoom/pan
- `MermaidArtifact.vue` - Interactive diagrams
- `JsonArtifact.vue` - Formatted JSON viewer
- `MarkdownArtifact.vue` - Rendered markdown content

#### Integration with Message Component

```vue
<!-- In Message/index.vue -->
<template>
  <div class="message-content">
    <div class="message-text">{{ message.text }}</div>
    <div v-if="message.artifacts" class="message-artifacts">
      <ArtifactViewer 
        v-for="artifact in message.artifacts" 
        :key="artifact.uuid"
        :artifact="artifact"
      />
    </div>
  </div>
</template>
```

### 4. Artifact Detection Patterns

#### Code Artifacts

```
```javascript <!-- artifact: React Component -->
function MyComponent() {
  return <div>Hello World</div>;
}
```

#### HTML Artifacts

```html <!-- artifact: Interactive Demo -->
<div id="demo">
  <button onclick="alert('Hello!')">Click me</button>
</div>
```

#### SVG Artifacts

```svg <!-- artifact: Logo Design -->
<svg viewBox="0 0 100 100">
  <circle cx="50" cy="50" r="40" fill="blue" />
</svg>
```

### 5. Artifact Types to Support

1. **Code Artifacts**
   - Interactive code editors
   - Syntax highlighting
   - Copy/download functionality
   - Language detection

2. **HTML Artifacts**
   - Live HTML preview
   - Sandboxed iframe execution
   - CSS/JS support

3. **SVG Artifacts**
   - Vector graphics display
   - Zoom/pan functionality
   - Export options

4. **Mermaid Diagrams**
   - Flowcharts, sequence diagrams
   - Interactive navigation
   - Export to image

5. **JSON/Data Artifacts**
   - Formatted JSON viewer
   - Collapsible tree structure
   - Search functionality

6. **Markdown Artifacts**
   - Rendered markdown content
   - Table of contents
   - Export options

### 6. Implementation Phases

#### Phase 1: Core Infrastructure

- [ ] Database schema updates
- [ ] Backend artifact detection logic
- [ ] Basic frontend artifact viewer component

#### Phase 2: Code Artifacts

- [ ] Code artifact component with syntax highlighting
- [ ] Copy/download functionality
- [ ] Language detection and validation

#### Phase 3: Web Artifacts

- [ ] HTML artifact component with sandboxing
- [ ] SVG artifact viewer
- [ ] CSS/JS execution in sandbox

#### Phase 4: Advanced Features

- [ ] Mermaid diagram support
- [ ] JSON/data viewer
- [ ] Markdown artifact rendering

#### Phase 5: Polish & Features

- [ ] Artifact editing capabilities
- [ ] Sharing and export options
- [ ] Performance optimizations
- [ ] Mobile responsiveness

### 7. Technical Considerations

#### Security

- Sandbox HTML/JS execution to prevent XSS
- Validate and sanitize artifact content
- Limit artifact size and complexity

#### Performance

- Lazy loading of artifact components
- Virtualization for large artifacts
- Caching of rendered content

#### User Experience

- Collapsible artifact containers
- Responsive design for mobile
- Keyboard shortcuts for artifact actions
- Loading states for complex artifacts

### 8. Testing Strategy

#### Backend Testing

- Unit tests for artifact detection logic
- Integration tests for artifact API endpoints
- Database migration tests

#### Frontend Testing

- Component tests for artifact viewers
- Integration tests for message rendering
- E2E tests for artifact interactions

### 9. Deployment Considerations

#### Database Migration

- Safe migration strategy for existing messages
- Rollback plan for schema changes
- Index optimization for artifact queries

#### Feature Flags

- Gradual rollout of artifact types
- A/B testing for UI improvements
- Performance monitoring

## Next Steps

1. Review and approve implementation plan
2. Set up development environment
3. Begin with Phase 1 implementation
4. Iterate based on user feedback
5. Expand to additional artifact types

## Resources

- Current codebase structure in `/web/src/views/chat/components/Message/`
- Database schema in `/api/sqlc/schema.sql`
- Message handling in `/api/chat_message_handler.go`
- Frontend message types in `/web/src/types/chat.d.ts`
