package main

import (
	"bufio"
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/swuecho/chat_backend/llm/gemini"
	"github.com/swuecho/chat_backend/models"
	"github.com/swuecho/chat_backend/sqlc_queries"
)

// Generated by curl-to-Go: https://mholt.github.io/curl-to-go

// curl https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=$API_KEY \
//     -H 'Content-Type: application/json' \
//     -X POST \
//     -d '{
//       "contents": [{
//         "parts":[{
//           "text": "Write a story about a magic backpack."}]}]}' 2> /dev/null

// GeminiClient handles communication with the Gemini API
type GeminiClient struct {
	client *http.Client
}

// NewGeminiClient creates a new Gemini API client
func NewGeminiClient() *GeminiClient {
	return &GeminiClient{
		client: &http.Client{Timeout: 5 * time.Minute},
	}
}

// Gemini ChatModel implementation
type GeminiChatModel struct {
	h      *ChatHandler
	client *GeminiClient
}

func NewGeminiChatModel(h *ChatHandler) *GeminiChatModel {
	return &GeminiChatModel{
		h:      h,
		client: NewGeminiClient(),
	}
}

func (m *GeminiChatModel) Stream(w http.ResponseWriter, chatSession sqlc_queries.ChatSession, messages []models.Message, chatUuid string, regenerate bool, stream bool) (*models.LLMAnswer, error) {
	answerID := GenerateAnswerID(chatUuid, regenerate)

	chatFiles, err := GetChatFiles(m.h.chatfileService.q, chatSession.Uuid)
	if err != nil {
		return nil, err
	}

	payloadBytes, err := gemini.GenGemminPayload(messages, chatFiles)
	if err != nil {
		return nil, ErrInternalUnexpected.WithMessage("Failed to generate Gemini payload").WithDebugInfo(err.Error())
	}

	url := gemini.BuildAPIURL(chatSession.Model, stream)
	req, err := http.NewRequest("POST", url, bytes.NewBuffer(payloadBytes))
	if err != nil {
		return nil, ErrInternalUnexpected.WithMessage("Failed to create Gemini API request").WithDebugInfo(err.Error())
	}
	req.Header.Set("Content-Type", "application/json")

	if stream {
		return m.handleStreamResponse(w, req, answerID)
	}

	llmAnswer, err := gemini.HandleRegularResponse(*m.client.client, req)
	if err != nil {
		return nil, ErrInternalUnexpected.WithMessage("Failed to generate regular resposne").WithDebugInfo(err.Error())
	}
	if llmAnswer != nil {
		llmAnswer.AnswerId = answerID
	}
	response := constructChatCompletionStreamResponse(answerID, llmAnswer.Answer)
	data, _ := json.Marshal(response)
	fmt.Fprint(w, string(data))
	return llmAnswer, err
}

func GenerateChatTitle(ctx context.Context, model, chatText string) (string, error) {
	// Validate API key
	apiKey := os.Getenv("GEMINI_API_KEY")
	if apiKey == "" {
		return "", ErrInternalUnexpected.WithMessage("GEMINI_API_KEY environment variable not set")
	}

	// Validate input
	if strings.TrimSpace(chatText) == "" {
		return "", ErrValidationInvalidInput("chat text cannot be empty")
	}

	// Create properly formatted Gemini messages
	messages := []models.Message{
		{
			Role:    "user",
			Content: "Generate a concise and descriptive title (max 10 words) for this chat conversation, no special characters.",
		},
		{
			Role:    "user",
			Content: chatText,
		},
	}

	// Generate proper Gemini payload
	payloadBytes, err := gemini.GenGemminPayload(messages, nil)
	if err != nil {
		return "", ErrInternalUnexpected.WithMessage("Failed to generate Gemini payload").WithDebugInfo(err.Error())
	}

	// Build URL with proper API key
	url := gemini.BuildAPIURL(model, false)
	req, err := http.NewRequest("POST", url, bytes.NewBuffer(payloadBytes))
	if err != nil {
		return "", ErrInternalUnexpected.WithMessage("Failed to create Gemini API request").WithDebugInfo(err.Error())
	}
	req.Header.Set("Content-Type", "application/json")
	answer, err := gemini.HandleRegularResponse(http.Client{Timeout: 1 * time.Minute}, req)
	if err != nil {
		return "", ErrInternalUnexpected.WithMessage("Failed to handle Gemini response").WithDebugInfo(err.Error())
	}

	// Validate and clean up response
	if answer == nil || answer.Answer == "" {
		return "", ErrInternalUnexpected.WithMessage("Empty response from Gemini")
	}

	title := strings.TrimSpace(answer.Answer)
	title = strings.Trim(title, `"`)
	title = strings.Trim(title, `*`)
	if title == "" {
		return "", ErrInternalUnexpected.WithMessage("Invalid title generated")
	}

	// Truncate and return
	return firstN(title, 100), nil
}

func (m *GeminiChatModel) handleStreamResponse(w http.ResponseWriter, req *http.Request, answerID string) (*models.LLMAnswer, error) {
	resp, err := m.client.client.Do(req)
	if err != nil {
		return nil, ErrInternalUnexpected.WithMessage("Failed to send Gemini API request").WithDebugInfo(err.Error())
	}
	defer resp.Body.Close()

	flusher, err := setupSSEStream(w)
	if err != nil {
		return nil, APIError{
			HTTPCode: http.StatusInternalServerError,
			Code:     "STREAM_UNSUPPORTED",
			Message:  "Streaming unsupported by client",
		}
	}

	var answer string
	log.Println(resp.StatusCode)
	if resp.StatusCode != http.StatusOK {
		errorBody, _ := io.ReadAll(resp.Body)
		log.Println(string(errorBody))
		var apiError gemini.GoogleApiError
		if json.Unmarshal(errorBody, &apiError) == nil && apiError.Error.Message != "" {
			log.Printf("API returned non-200 status: %d %s. Error: %s", resp.StatusCode, http.StatusText(resp.StatusCode), &apiError)
		} else {
			log.Printf("API returned non-200 status: %d %s. Body: %s", resp.StatusCode, http.StatusText(resp.StatusCode), string(errorBody))
		}
		return nil, APIError{
			HTTPCode: apiError.Error.Code,
			Code:     apiError.Error.Status,
			Message:  apiError.Error.Message,
		}
	}
	ioreader := bufio.NewReader(resp.Body)
	headerData := []byte("data: ")

	for count := 0; count < 10000; count++ {
		line, err := ioreader.ReadBytes('\n')
		if err != nil {
			if errors.Is(err, io.EOF) {
				return &models.LLMAnswer{
					Answer:   answer,
					AnswerId: answerID,
				}, nil
			}
			return nil, ErrInternalUnexpected.WithMessage("Error reading stream").WithDebugInfo(err.Error())
		}

		if !bytes.HasPrefix(line, headerData) {
			continue
		}

		line = bytes.TrimPrefix(line, headerData)
		if len(line) > 0 {
			delta := gemini.ParseRespLineDelta(line)
			answer += delta // Accumulate delta for final answer storage
			// Send only the delta content
			if len(delta) > 0 {
				err := FlushResponse(w, flusher, StreamingResponse{
					AnswerID: answerID,
					Content:  delta,
					IsFinal:  false,
				})
				if err != nil {
					log.Printf("Failed to flush response: %v", err)
				}
			}
		}
	}

	return &models.LLMAnswer{
		AnswerId: answerID,
		Answer:   answer,
	}, nil
}
