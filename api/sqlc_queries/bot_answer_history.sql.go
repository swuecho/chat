// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: bot_answer_history.sql

package sqlc_queries

import (
	"context"
	"time"
)

const createBotAnswerHistory = `-- name: CreateBotAnswerHistory :one

INSERT INTO bot_answer_history (
    bot_uuid,
    user_id,
    prompt,
    answer,
    model,
    tokens_used
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, bot_uuid, user_id, prompt, answer, model, tokens_used, created_at, updated_at
`

type CreateBotAnswerHistoryParams struct {
	BotUuid    string `json:"botUuid"`
	UserID     int32  `json:"userID"`
	Prompt     string `json:"prompt"`
	Answer     string `json:"answer"`
	Model      string `json:"model"`
	TokensUsed int32  `json:"tokensUsed"`
}

// Bot Answer History Queries --
func (q *Queries) CreateBotAnswerHistory(ctx context.Context, arg CreateBotAnswerHistoryParams) (BotAnswerHistory, error) {
	row := q.db.QueryRowContext(ctx, createBotAnswerHistory,
		arg.BotUuid,
		arg.UserID,
		arg.Prompt,
		arg.Answer,
		arg.Model,
		arg.TokensUsed,
	)
	var i BotAnswerHistory
	err := row.Scan(
		&i.ID,
		&i.BotUuid,
		&i.UserID,
		&i.Prompt,
		&i.Answer,
		&i.Model,
		&i.TokensUsed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteBotAnswerHistory = `-- name: DeleteBotAnswerHistory :exec
DELETE FROM bot_answer_history WHERE id = $1
`

func (q *Queries) DeleteBotAnswerHistory(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteBotAnswerHistory, id)
	return err
}

const getBotAnswerHistoryByBotUUID = `-- name: GetBotAnswerHistoryByBotUUID :many
SELECT 
    bah.id,
    bah.bot_uuid,
    bah.user_id,
    bah.prompt,
    bah.answer,
    bah.model,
    bah.tokens_used,
    bah.created_at,
    bah.updated_at,
    au.username AS user_username,
    au.email AS user_email
FROM bot_answer_history bah
JOIN auth_user au ON bah.user_id = au.id
WHERE bah.bot_uuid = $1
ORDER BY bah.created_at DESC
LIMIT $2 OFFSET $3
`

type GetBotAnswerHistoryByBotUUIDParams struct {
	BotUuid string `json:"botUuid"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetBotAnswerHistoryByBotUUIDRow struct {
	ID           int32     `json:"id"`
	BotUuid      string    `json:"botUuid"`
	UserID       int32     `json:"userID"`
	Prompt       string    `json:"prompt"`
	Answer       string    `json:"answer"`
	Model        string    `json:"model"`
	TokensUsed   int32     `json:"tokensUsed"`
	CreatedAt    time.Time `json:"createdAt"`
	UpdatedAt    time.Time `json:"updatedAt"`
	UserUsername string    `json:"userUsername"`
	UserEmail    string    `json:"userEmail"`
}

func (q *Queries) GetBotAnswerHistoryByBotUUID(ctx context.Context, arg GetBotAnswerHistoryByBotUUIDParams) ([]GetBotAnswerHistoryByBotUUIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getBotAnswerHistoryByBotUUID, arg.BotUuid, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBotAnswerHistoryByBotUUIDRow
	for rows.Next() {
		var i GetBotAnswerHistoryByBotUUIDRow
		if err := rows.Scan(
			&i.ID,
			&i.BotUuid,
			&i.UserID,
			&i.Prompt,
			&i.Answer,
			&i.Model,
			&i.TokensUsed,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserUsername,
			&i.UserEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBotAnswerHistoryByID = `-- name: GetBotAnswerHistoryByID :one
SELECT 
    bah.id,
    bah.bot_uuid,
    bah.user_id,
    bah.prompt,
    bah.answer,
    bah.model,
    bah.tokens_used,
    bah.created_at,
    bah.updated_at,
    au.username AS user_username,
    au.email AS user_email
FROM bot_answer_history bah
JOIN auth_user au ON bah.user_id = au.id
WHERE bah.id = $1
`

type GetBotAnswerHistoryByIDRow struct {
	ID           int32     `json:"id"`
	BotUuid      string    `json:"botUuid"`
	UserID       int32     `json:"userID"`
	Prompt       string    `json:"prompt"`
	Answer       string    `json:"answer"`
	Model        string    `json:"model"`
	TokensUsed   int32     `json:"tokensUsed"`
	CreatedAt    time.Time `json:"createdAt"`
	UpdatedAt    time.Time `json:"updatedAt"`
	UserUsername string    `json:"userUsername"`
	UserEmail    string    `json:"userEmail"`
}

func (q *Queries) GetBotAnswerHistoryByID(ctx context.Context, id int32) (GetBotAnswerHistoryByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getBotAnswerHistoryByID, id)
	var i GetBotAnswerHistoryByIDRow
	err := row.Scan(
		&i.ID,
		&i.BotUuid,
		&i.UserID,
		&i.Prompt,
		&i.Answer,
		&i.Model,
		&i.TokensUsed,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserUsername,
		&i.UserEmail,
	)
	return i, err
}

const getBotAnswerHistoryByUserID = `-- name: GetBotAnswerHistoryByUserID :many
SELECT 
    bah.id,
    bah.bot_uuid,
    bah.user_id,
    bah.prompt,
    bah.answer,
    bah.model,
    bah.tokens_used,
    bah.created_at,
    bah.updated_at,
    au.username AS user_username,
    au.email AS user_email
FROM bot_answer_history bah
JOIN auth_user au ON bah.user_id = au.id
WHERE bah.user_id = $1
ORDER BY bah.created_at DESC
LIMIT $2 OFFSET $3
`

type GetBotAnswerHistoryByUserIDParams struct {
	UserID int32 `json:"userID"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetBotAnswerHistoryByUserIDRow struct {
	ID           int32     `json:"id"`
	BotUuid      string    `json:"botUuid"`
	UserID       int32     `json:"userID"`
	Prompt       string    `json:"prompt"`
	Answer       string    `json:"answer"`
	Model        string    `json:"model"`
	TokensUsed   int32     `json:"tokensUsed"`
	CreatedAt    time.Time `json:"createdAt"`
	UpdatedAt    time.Time `json:"updatedAt"`
	UserUsername string    `json:"userUsername"`
	UserEmail    string    `json:"userEmail"`
}

func (q *Queries) GetBotAnswerHistoryByUserID(ctx context.Context, arg GetBotAnswerHistoryByUserIDParams) ([]GetBotAnswerHistoryByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getBotAnswerHistoryByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBotAnswerHistoryByUserIDRow
	for rows.Next() {
		var i GetBotAnswerHistoryByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.BotUuid,
			&i.UserID,
			&i.Prompt,
			&i.Answer,
			&i.Model,
			&i.TokensUsed,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserUsername,
			&i.UserEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBotAnswerHistoryCountByBotUUID = `-- name: GetBotAnswerHistoryCountByBotUUID :one
SELECT COUNT(*) FROM bot_answer_history WHERE bot_uuid = $1
`

func (q *Queries) GetBotAnswerHistoryCountByBotUUID(ctx context.Context, botUuid string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getBotAnswerHistoryCountByBotUUID, botUuid)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getBotAnswerHistoryCountByUserID = `-- name: GetBotAnswerHistoryCountByUserID :one
SELECT COUNT(*) FROM bot_answer_history WHERE user_id = $1
`

func (q *Queries) GetBotAnswerHistoryCountByUserID(ctx context.Context, userID int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, getBotAnswerHistoryCountByUserID, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getLatestBotAnswerHistoryByBotUUID = `-- name: GetLatestBotAnswerHistoryByBotUUID :many
SELECT 
    bah.id,
    bah.bot_uuid,
    bah.user_id,
    bah.prompt,
    bah.answer,
    bah.model,
    bah.tokens_used,
    bah.created_at,
    bah.updated_at,
    au.username AS user_username,
    au.email AS user_email
FROM bot_answer_history bah
JOIN auth_user au ON bah.user_id = au.id
WHERE bah.bot_uuid = $1
ORDER BY bah.created_at DESC
LIMIT $2
`

type GetLatestBotAnswerHistoryByBotUUIDParams struct {
	BotUuid string `json:"botUuid"`
	Limit   int32  `json:"limit"`
}

type GetLatestBotAnswerHistoryByBotUUIDRow struct {
	ID           int32     `json:"id"`
	BotUuid      string    `json:"botUuid"`
	UserID       int32     `json:"userID"`
	Prompt       string    `json:"prompt"`
	Answer       string    `json:"answer"`
	Model        string    `json:"model"`
	TokensUsed   int32     `json:"tokensUsed"`
	CreatedAt    time.Time `json:"createdAt"`
	UpdatedAt    time.Time `json:"updatedAt"`
	UserUsername string    `json:"userUsername"`
	UserEmail    string    `json:"userEmail"`
}

func (q *Queries) GetLatestBotAnswerHistoryByBotUUID(ctx context.Context, arg GetLatestBotAnswerHistoryByBotUUIDParams) ([]GetLatestBotAnswerHistoryByBotUUIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getLatestBotAnswerHistoryByBotUUID, arg.BotUuid, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLatestBotAnswerHistoryByBotUUIDRow
	for rows.Next() {
		var i GetLatestBotAnswerHistoryByBotUUIDRow
		if err := rows.Scan(
			&i.ID,
			&i.BotUuid,
			&i.UserID,
			&i.Prompt,
			&i.Answer,
			&i.Model,
			&i.TokensUsed,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserUsername,
			&i.UserEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBotAnswerHistory = `-- name: UpdateBotAnswerHistory :one
UPDATE bot_answer_history
SET
    answer = $2,
    tokens_used = $3,
    updated_at = NOW()
WHERE id = $1
RETURNING id, bot_uuid, user_id, prompt, answer, model, tokens_used, created_at, updated_at
`

type UpdateBotAnswerHistoryParams struct {
	ID         int32  `json:"id"`
	Answer     string `json:"answer"`
	TokensUsed int32  `json:"tokensUsed"`
}

func (q *Queries) UpdateBotAnswerHistory(ctx context.Context, arg UpdateBotAnswerHistoryParams) (BotAnswerHistory, error) {
	row := q.db.QueryRowContext(ctx, updateBotAnswerHistory, arg.ID, arg.Answer, arg.TokensUsed)
	var i BotAnswerHistory
	err := row.Scan(
		&i.ID,
		&i.BotUuid,
		&i.UserID,
		&i.Prompt,
		&i.Answer,
		&i.Model,
		&i.TokensUsed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
